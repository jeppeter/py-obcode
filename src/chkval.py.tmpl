#! /usr/bin/env python

import logging
import os
import sys
import re
import random
import zlib
import sha3
import hashlib

sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from strparser import *
from jsonhdl import *
from cobfilebase import *


##extractcode_start

C_CODE_CRC32CALC='''%C_CODE_CRC32CALC%'''
C_CODE_MD5CALC='''%C_CODE_MD5CALC%'''
C_CODE_SHA256CALC='''%C_CODE_SHA256CALC%'''
C_CODE_SHA3CALC='''%C_CODE_SHA3CALC%'''
C_CODE_CHKVALDEF='''%C_CODE_CHKVALDEF%'''
C_CODE_CHKVAL='''%C_CODE_CHKVAL%'''
C_CODE_AES='''%C_CODE_AES%'''


class ChkVal(COBFileBase):
    def __init__(self,sfile,dfile=None,cfg=None):
        COBFileBase.__init__(self,sfile,dfile,cfg)      
        self.__ob_random_name_expr = re.compile('.*(OB_RANDOM_NAME\s*(\(.*))$')
        self.__ob_random_name_spec_expr = re.compile('.*(OB_RANDOM_NAME_SPEC\s*(\(.*))$')
        self.__ob_chkval_func_expr = re.compile('.*(OB_CHKVAL_FUNC\s*(\(.*))$')
        self.__ob_chkval_func_spec_expr = re.compile('.*(OB_CHKVAL_FUNC_SPEC\s*(\(.*))$')
        self.__ob_expand_code_expr = re.compile('\s+(OB_EXPAND_CODE\s*(\\\x28.*))$')
        self.__ob_expand_code_spec_expr = re.compile('\s+(OB_EXPAND_CODE_SPEC\s*(\\\x28.*))$')
        return

    def __format_ob_random_name_inner(self,objname,odict,cfg,params,before,after):
        assert(len(params) == 1)
        bs = string_to_ints(params[0])
        bs.insert(0,ord('"'))
        bs.append(ord('"'))
        sbyte,lbyte = parse_string(bs)
        assert(len(lbyte) <= 1)
        if len(lbyte) > 0 :
            assert(lbyte[0] == 0)
        rs = ints_to_string(sbyte)

        rndname = get_odict_value(odict,RANDOM_VARIABLE,objname,rs)
        if rndname is None:
            rndname = get_random_name(random.randint(cfg.namemin,cfg.namemax))
            odict = set_odict_value(odict,rndname,RANDOM_VARIABLE,objname,rs)
            #odict[RANDOM_VARIABLE][objname][rs] = get_random_name(random.randint(cfg.namemin,cfg.namemax))
        newc = before
        newc += rndname
        newc += after
        return newc,odict


    def __format_ob_random_name_func(self,l,objname,odict):
        cfg , params, before ,after = self.get_variables(l, self.__ob_random_name_expr)
        return self.__format_ob_random_name_inner(objname,odict,cfg,params,before,after)

    def __format_ob_random_name_spec_func(self,l,objname,odict):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_mixed_str_spec_expr)
        return self.__format_ob_random_name_inner(objname,odict,cfg,params,before,after)

    def __format_c_line(self,origc,objname,odict):
        newc = origc        
        # now we should get the
        while True:
            if self.get_filter_expr_not_defined(newc,self.__ob_random_name_expr):
                newc, odict = self.__format_ob_random_name_func(newc,objname,odict)
            elif self.get_filter_expr_not_defined(newc,self.__ob_random_name_spec_expr):
                newc, odict = self.__format_ob_random_name_spec_func(newc,objname,odict)
            else:
                break
        return newc,odict

    def __format_multi_lines(self,mlines,objname,odict):
        rets = ''
        sarr = re.split('\n',mlines)
        for l in sarr:
            l = l.rstrip('\r\n')
            r , odict = self.__format_c_line(l,objname,odict)
            rets += '%s\n'%(r)
        return rets,odict

    def __format_char_array(self,odict,num,*path):
        name = get_odict_value(odict,RANDOM_VARIABLE,*path)
        if name is None:
            name = get_random_name(20)
            odict = set_odict_value(odict,name, RANDOM_VARIABLE,*path)

        sarr = get_odict_value(odict,CHKVAL_OBJ_DATA,*path)
        if sarr is None:
            sarr = get_random_bytes(num)
            odict = set_odict_value(odict,sarr,CHKVAL_OBJ_DATA,*path)

        rets = format_line('unsigned char %s[%d]={%s};'%(name,num,format_bytes_c(sarr)), 0)
        return rets,odict


    def __get_ll_value(self,sarr):
        llval = 0
        idx = 0
        while idx < len(sarr):
            llval += (sarr[idx] << (idx * 8))
            idx += 1
        return llval


    def __format_sarr_struct(self,odict,name,size,tabs,lastone,*path):
        rets = ''
        sarr = get_odict_value(odict,*path)
        if sarr is None:
            sarr = get_random_bytes(size)
            odict = set_odict_value(odict,sarr,*path)
        rets += format_debug_line('%s'%(name),tabs + 1, 3)
        if lastone:
            rets += format_line('{%s}'%(format_bytes_c(sarr)), tabs + 1)
        else:
            rets += format_line('{%s},'%(format_bytes_c(sarr)), tabs + 1)
        return rets, odict


    def __format_check_value_single(self,odict,f,tabs,lastone,*path):
        rets = ''
        rets += format_line('{', tabs)
        rets += format_debug_line('function %s'%(f), tabs + 1, 3)
        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_OFFSET)
        sarr = get_odict_value(odict,*curpath)
        if sarr is None:
            sarr = get_random_bytes(CHKVAL_STRUCT_OFFSET_SIZE)
            odict = set_odict_value(odict,sarr, *curpath)
        rets += format_debug_line('%s'%(CHKVAL_STRUCT_OFFSET),tabs+1,3)
        llval = self.__get_ll_value(sarr)
        rets += format_line('(signed long long) OB_LL_VALUE(0x%x),'%(llval), tabs+1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SIZE)
        sarr = get_odict_value(odict,*curpath)
        if sarr is None:
            sarr = get_random_bytes(CHKVAL_STRUCT_SIZE_SIZE)
            odict = set_odict_value(odict,sarr,*curpath)
        llval = self.__get_ll_value(sarr)
        rets += format_debug_line(' %s value'%(CHKVAL_STRUCT_SIZE),tabs+1,3)
        rets += format_line('(unsigned long long) OB_ULL_VALUE(0x%x),'%(llval), tabs + 1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_CRC32VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_CRC32VAL,CHKVAL_STRUCT_CRC32VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SHA256VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_SHA256VAL,CHKVAL_STRUCT_SHA256VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_NAMEXOR1)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_NAMEXOR1,CHKVAL_STRUCT_NAMEXOR1_SIZE,tabs,False,*curpath)
        rets += curs

        sarr1 = get_odict_value(odict,*curpath)
        assert(sarr1 is not None)
        namexors = string_to_ints(f)
        if len(namexors) >= CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors = namexors[:(CHKVAL_STRUCT_NAMEXOR1_SIZE-1)]
        if len(namexors) < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors.append(0)
        while len(namexors) < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors.append(random.randint(0,255))
        sarr2 = []
        idx = 0
        while idx < CHKVAL_STRUCT_NAMEXOR2_SIZE:
            sarr2.append(0)
            idx += 1

        idx = 0
        while idx < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            sarr2[idx] = namexors[idx] ^ sarr1[idx]
            idx += 1
        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_NAMEXOR2)
        odict = set_odict_value(odict,sarr2, *curpath)
        rets += format_debug_line('%s'%(CHKVAL_STRUCT_NAMEXOR2), tabs+ 1, 3)
        rets += format_line('{%s},'%(format_bytes_c(sarr2)), tabs+1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SHA3VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_SHA3VAL,CHKVAL_STRUCT_SHA3VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_MD5VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_MD5VAL,CHKVAL_STRUCT_MD5VAL_SIZE,tabs,True,*curpath)
        rets += curs

        if lastone:
            rets += format_line('}', tabs)
        else:
            rets += format_line('},', tabs)
        return rets,odict


    def __format_check_value(self,odict,objname,o,chkfuncs=[]):
        odict = create_odict_is_none(odict,CHKVAL_RANDOM_VALUE,objname,o)
        curs , odict = self.__format_char_array(odict,16,objname,CHKVAL_FUNC_CHECKS_START)
        funcchecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)
        if funcchecks is None:
            funcchecks = get_random_name(20)
            odict = set_odict_value(odict,funcchecks, RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)

        idx = 0
        for f in chkfuncs:
            curs, odict = self.__format_check_value_single(odict,f,1,False,CHKVAL_RANDOM_VALUE,objname,o,f)

        curs ,odict = self.__format_char_array(odict,16,objname,CHKVAL_FUNC_CHECKS_END)

        valuechecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)
        if valuechecks is None:
            valuechecks = get_random_name(20)
            odict = set_odict_value(odict,valuechecks, RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)

        curs , odict = self.__format_check_value_single(odict,CHKVAL_VALUE_CHECKS_DICT,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_VALUE_CHECKS)
        return odict

    def format_c_code_pre(self,odict,objname):
        logging.info('objname [%s]'%(objname))
        odict = create_odict_is_none(odict, RANDOM_VARIABLE,objname)
        odict = create_odict_is_none(odict,CHKVAL_RANDOM_VALUE,objname)

        rets = ''

        curs , odict = self.__format_multi_lines(C_CODE_CHKVALDEF,objname,odict)
        rets += curs

        curs,odict = self.__format_multi_lines(C_CODE_CRC32CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_MD5CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_SHA256CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_SHA3CALC, objname,odict)
        rets += curs

        curs , odict = self.__format_multi_lines(C_CODE_AES,objname,odict)
        rets += curs

        return rets,odict

    def format_c_code_post(self,odict,objname):
        rets= ''        
        logging.info('objname [%s]'%(objname))
        curs, odict = self.__format_multi_lines(C_CODE_CHKVAL,objname,odict)
        rets += curs
        return rets,odict

    def __write_check_value(self,odict,objname,jdict):
        rets = ''
        curs , odict = self.__format_char_array(odict,16,objname,CHKVAL_FUNC_CHECKS_START)
        rets += curs

        func_checks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)
        assert(func_checks is not None)

        rets += format_line('',0)
        rets += format_line('chkvalue_t %s[] = {'%(func_checks), 0)

        for o in jdict.keys():
            chkfuncs = jdict[o]
            for f in chkfuncs:
                curs, odict = self.__format_check_value_single(odict,f,1,False,CHKVAL_RANDOM_VALUE,objname,o,f)
                rets += curs

        #curs,odict = self.__format_check_value_single(odict,'',1,True,CHKVAL_RANDOM_VALUE,objname,CHKVAL_STRUCT_LASTONE,'')
        curs,odict = self.__format_check_value_single(odict,CHKVAL_STRUCT_LASTONE,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_STRUCT_LASTONE)
        rets += curs
        rets += format_line('};', 0)

        rets += format_line('', 0)
        curs ,odict = self.__format_char_array(odict,16,objname,CHKVAL_FUNC_CHECKS_END)
        rets += curs

        rets += format_line('', 0)

        valuechecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)
        assert(valuechecks is not None)
        rets += format_line('chkvalue_t %s[1] = {'%(valuechecks),0)
        curs , odict = self.__format_check_value_single(odict,CHKVAL_VALUE_CHECKS_DICT,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_VALUE_CHECKS)
        rets += curs
        rets += format_line('};',0)

        curs,odict = self.__format_char_array(odict,16,objname,CHKVAL_VALUE_CHECKS_TOTAL_END)
        rets += curs
        return rets



    def format_c_code(self,odict, objname,jdict):

        # this to check value
        logging.info('objname [%s]'%(objname))
        rets = ''
        for k in jdict.keys():
            logging.info('k [%s]'%(k))
            odict = self.__format_check_value(odict,objname,k,jdict[k])
        logging.info(' ')
        rets = self.__write_check_value(odict,objname,jdict)
        return rets,odict

    def output_chkval_func(self,funcname,objname,functype,tabs=0):
        rets = ''
        if funcname is not None:
            rets += format_line('',tabs)
            rets += format_debug_line(' %s %s func'%(objname,functype), tabs, 3)
            rets += format_line('int %s(m_check_fail_func_t failfunc);'%(funcname),tabs)
        return rets

    def __set_retodict(self,odict,retodict,objname,functype):
        func = get_odict_value(odict,RANDOM_VARIABLE,objname,functype)
        if func is not None:
            if objname not in retodict.keys():
                retodict[objname] = dict()
            retodict[objname][functype] = func
        return retodict


    def get_functions_odict(self,odict,objs):
        retodict=dict()
        for o in objs:
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_CRC32_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_MD5_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_SHA256_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_SHA3_FUNC)
        return retodict

    def format_chkval_header(self,odict,objs=[]):
        logging.info(' ')
        pregaurd = '__%s__'%(get_random_name(30))
        rets = ''
        rets += format_line('#ifndef %s'%(pregaurd),0)
        rets += format_line('#define %s'%(pregaurd),0)
        rets += format_line('',0)
        rets += format_line('#include <obcode.h>',0)
        rets += format_line('',0)
        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('extern "C" {', 0)
        rets += format_line('#endif /*__cplusplus*/',0)
        rets += format_line('',0)

        for o in objs:
            logging.info('o[%s]'%(o))
            crc32func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_CRC32_FUNC)
            md5func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_MD5_FUNC)
            sha256func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_SHA256_FUNC)
            sha3func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_SHA3_FUNC)
            rets += self.output_chkval_func(crc32func,o,'crc32')
            rets += self.output_chkval_func(md5func,o,'md5')
            rets += self.output_chkval_func(sha256func,o,'sha256')
            rets += self.output_chkval_func(sha3func,o,'sha3')

        rets += format_line('',0)
        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('};', 0)
        rets += format_line('#endif /*__cplusplus*/',0)
        rets += format_line('',0)
        rets += format_line('#endif /*%s*/'%(pregaurd),0)
        return rets

    def __format_ob_chkval_func_inner(self,l,retodict,cfg,params,before,after):
        idx = -1
        logging.info('')
        if len(retodict['FUNCS']) > 0:
            idx = random.randint(0,len(retodict['FUNCS']) - 1)
        logging.info('idx [%d]'%(idx))
        if idx < 0:
            # we do not have the functions ,so just keep 
            return '%s\n'%(l)
        typecall = retodict['TYPES'][idx]
        file = retodict['FILES'][idx]
        funcname = retodict['FUNCS'][idx]
        tabs = count_tabs(l)
        rets = ''
        rets += format_debug_line(' in [%s] for [%s] '%(file,typecall),tabs,3)
        rets += format_line('#line %d'%(self.cur_line),0)
        rets += before
        rets += '%s(%s)'%(funcname,params[0])
        rets += after
        rets += '\n'
        return rets



    def __format_ob_chkval_func(self,l,retodict):
        cfg ,params,before ,after = self.get_variables(l,self.__ob_chkval_func_expr)
        return self.__format_ob_chkval_func_inner(l,retodict,cfg,params,before,after)

    def __format_ob_chkval_func_spec(self,l,retodict):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_chkval_func_spec_expr)
        return self.__format_ob_chkval_func_inner(l,retodict,cfg,params,before,after)

    def __format_ob_expand_code_inner(self,l,params,cfg,before,after):
        rets = ''
        rets += self.expand_code(l,params,cfg,before,after)
        #rets += format_line('#line %d'%(self.cur_line),0)
        rets += format_line('%s'%(l),0)
        return rets

    def __format_ob_expand_code(self,l):
        cfg ,params,before ,after = self.get_variables(l,self.__ob_expand_code_expr)
        return self.__format_ob_expand_code_inner(l,params,cfg,before,after)

    def __format_ob_expand_code_spec(self,l):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_chkval_func_spec_expr)
        return self.__format_ob_expand_code_inner(l,params,cfg,before,after)

    def replace_functions(self,odict,objs=[]):
        logging.info('objs %s'%(objs))
        retodict = self.get_functions_odict(odict,objs)
        funccalls = []
        funcnames = []
        funcfiles = []
        for k in retodict.keys():
            for v in retodict[k].keys():
                funccalls.append(retodict[k][v])
                funcnames.append(v)
                funcfiles.append(k)
        retodict = dict()
        retodict['FILES'] = funcfiles
        retodict['FUNCS'] = funccalls
        retodict['TYPES'] = funcnames
        rets = ''
        self.cur_line = 0
        for l in self.in_lines:
            self.cur_line += 1
            l = l.rstrip('\r\n')
            logging.debug('[%d][%s]'%(self.cur_line, l))
            if self.get_filter_expr_not_defined(l,self.__ob_chkval_func_expr):
                logging.debug('')
                rets += self.__format_ob_chkval_func(l,retodict)
            elif self.get_filter_expr_not_defined(l, self.__ob_chkval_func_spec_expr):
                logging.debug('')
                rets += self.__format_ob_chkval_func_spec(l,retodict)
            else:
                rets += '%s\n'%(l)
        return rets


    def expand_chkval_code(self):
        self.cur_line = 0
        rets = ''
        for l in self.in_lines:
            self.cur_line += 1
            l = l.rstrip('\r\n')
            logging.debug('[%d][%s]'%(self.cur_line, l))
            if self.get_filter_expr_not_defined(l,self.__ob_expand_code_expr):
                rets += self.__format_ob_expand_code(l)
            elif self.get_filter_expr_not_defined(l,self.__ob_expand_code_spec_expr):
                rets += self.__format_ob_expand_code_spec(l)
            else:
                rets += '%s\n'%(l)
        return rets


def chkval_dump_object_function_one(args,objparser,odict,o,f,win32mode=False):
    logging.info('o[%s]f[%s]'%(o,f))
    fodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,o,f)
    realf = f
    if win32mode:
        realf = '_%s'%(f)
    if fodict is None:
        fodict = dict()
        fvaddr = objparser.func_vaddr(realf)
        foff = objparser.func_offset(realf)
        fsize = objparser.func_size(realf)
        if fvaddr < 0 or fsize < 0 or foff < 0:
            raise Exception('can not find [%s] in [%s]'%(f,o))
        alldata = objparser.get_data()
        relocs = []
        # just read the code ,and this is to search for the coding
        idx = 0
        while idx < fsize:
            relocs.append(objparser.is_in_reloc(fvaddr+idx,realf))
            idx += 1
        fodict = set_odict_value(fodict,alldata[foff:(foff + fsize)],CHKVAL_RDATA_DATAS)
        fodict = set_odict_value(fodict,relocs,CHKVAL_RDATA_RELOCS)
        odict = set_odict_value(odict,fodict,CHKVAL_KEY, CHKVAL_RAW_DATA,o,f)
    return odict

def chkval_dump_check_functions(args,objtype,odict,outname,win32mode=False):
    startfunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_START_FUNCTION_NAME)
    endfunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_END_FUNCTION_NAME)
    basefunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_BASE_FUNCTION_NAME)
    valuechkes = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_VALUE_CHECKS)
    assert(startfunc is not None)
    assert(endfunc is not None)
    assert(basefunc is not None)
    objparser = call_object_parser(objtype,outname)
    odict = chkval_dump_object_function_one(args,objparser,odict,outname, startfunc,win32mode)
    odict = chkval_dump_object_function_one(args,objparser, odict,outname, endfunc, win32mode)
    odict = chkval_dump_object_function_one(args,objparser, odict,outname, basefunc, win32mode)
    odict = chkval_dump_object_function_one(args,objparser,odict,outname, valuechkes, win32mode)
    objparser.close()
    objparser = None
    return odict

def chkval_dump_object_functions(args,objtype,odict,objs=[],win32mode=False):
    rval = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,args.output)
    if rval is not None:
        for o in objs:
            curobjparser= call_object_parser(objtype,o)
            rval = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,args.output,o)
            if rval is None:
                logging.warn('can not get [%s]'%(o))
                continue
            for f in rval.keys():
                odict = chkval_dump_object_function_one(args,curobjparser,odict,o,f,win32mode)
            curobjparser.close()
    else:
        logging.info('[%s]None handle'%(args.output))

    # now we should get the output function value
    odict = chkval_dump_check_functions(args,objtype,odict,args.output,win32mode)
    return odict

def chkval_get_realdata(objparser,exefile,odict,rawdata,objname,funcname,win32mode):
    realdata = []
    realdata.extend(rawdata)
    exeodict = get_odict_value(odict,PATCH_FUNC_KEY,exefile,objname,funcname)
    if exeodict is not None:
        # this is patched, so we should give this to the xors
        offsetk = get_odict_value(exeodict,FORMAT_FUNC_OFFSET_KEY)
        xors = get_odict_value(exeodict,FORMAT_FUNC_XORS_KEY)
        assert(offsetk is not None)
        assert(xors is not None)
        for offk in offsetk.keys():
            offi = int(offk)
            if offsetk[offk] >= 2:
                logging.debug('[%s].[%s].[0x%x:%d] [0x%02x] ^ [0x%02x] = [0x%02x]'%(objname,funcname,offi,offi,realdata[offi],xors[offk],(realdata[offi] ^ xors[offk])))
                realdata[offi] = realdata[offi] ^ xors[offk]
    return realdata

def get_crc32_value(rawdata):
    crc32val = zlib.crc32(ints_to_bytes(rawdata))
    if crc32val  >= 0x80000000:
        crc32val = (1 << 32) - crc32val
    elif crc32val < 0:
        crc32val = (1 << 32) + crc32val
    return '%x'%(crc32val)

def get_md5_value(rawdata):
    m = hashlib.md5()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_sha256_value(rawdata):
    m = hashlib.sha256()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_sha3_value(rawdata):
    m = sha3.sha3_512()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_crc_sum(rawdata):
    idx = 0
    crcval = 0
    size = len(rawdata)
    curval = 0
    while idx < size:
        curval = 0
        jdx = 0
        while jdx < (size - idx) and jdx < 4:
            curval += ((rawdata[(idx + jdx)]) << (jdx * 8))
            jdx += 1
        crcval += curval
        # not overflow
        crcval = crcval & 0xffffffff
        idx += 4
    return crcval

def format_calc_bytes(alldata,val,storesize,calcsize,pos,bigendian=False,note=''):
    b = format_bytes(val,calcsize,bigendian)
    assert(calcsize <= storesize)
    if storesize > calcsize:
        b.extend(zero_bytes(storesize - calcsize))
    return set_data_bytes(alldata,b,pos,note)


def chkval_fill_inc_obj_func(args,objparser,exefile,alldata,odict,incfile,objfile,funcname,basefuncoff,win32mode):
    # now get the k value
    datas = get_odict_value(odict, CHKVAL_KEY,CHKVAL_RAW_DATA,objfile,funcname,CHKVAL_RDATA_DATAS)
    relocs = get_odict_value(odict, CHKVAL_KEY,CHKVAL_RAW_DATA,objfile,funcname,CHKVAL_RDATA_RELOCS)
    assert(datas is not None)
    assert(relocs is not None)
    # now to get function store data
    rnddatadict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,incfile,objfile,funcname)
    realf = funcname
    if win32mode:
        realf = '_%s'%(funcname)
    assert(rnddatadict is not None)
    crc32rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_CRC32VAL)
    sha256rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SHA256VAL)
    sha3rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SHA3VAL)
    md5rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_MD5VAL)
    sizernddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SIZE)
    offsetrnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_OFFSET)

    crc32foff = objparser.get_text_file_off(crc32rnddata,zero_bytes(CHKVAL_STRUCT_CRC32VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_CRC32VAL))
    sha256foff = objparser.get_text_file_off(sha256rnddata,zero_bytes(CHKVAL_STRUCT_SHA256VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SHA256VAL))
    sha3foff = objparser.get_text_file_off(sha3rnddata,zero_bytes(CHKVAL_STRUCT_SHA3VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SHA3VAL))
    md5foff = objparser.get_text_file_off(md5rnddata,zero_bytes(CHKVAL_STRUCT_MD5VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_MD5VAL))
    sizefoff = objparser.get_text_file_off(sizernddata,zero_bytes(CHKVAL_STRUCT_SIZE_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SIZE))
    offsetfoff = objparser.get_text_file_off(offsetrnddata,zero_bytes(CHKVAL_STRUCT_OFFSET_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_OFFSET))

    foff = objparser.get_text_file_off(datas,relocs,realf)
    rawdata = alldata[foff:(foff + len(relocs))]
    realdata = chkval_get_realdata(objparser,exefile,odict,rawdata,objfile,funcname,win32mode)
    # to give the data set
    if foff > basefuncoff:
        setoffset = (foff - basefuncoff)
    else:
        setoffset = (basefuncoff - foff)
        setoffset = (0x1 << 64) - setoffset
    
    crc32val = get_crc32_value(realdata)
    md5val = get_md5_value(realdata)
    sha256val = get_sha256_value(realdata)
    sha3val = get_sha3_value(realdata)

    alldata = format_calc_bytes(alldata,crc32val,CHKVAL_STRUCT_CRC32VAL_SIZE,CALC_CRC32_SIZE,crc32foff,False,'[%s].[%s].[%s][crc32]'%(incfile,objfile,funcname))
    alldata = format_calc_bytes(alldata,md5val,CHKVAL_STRUCT_MD5VAL_SIZE,CALC_MD5_SIZE,md5foff,True,'[%s].[%s].[%s][md5]'%(incfile,objfile,funcname))
    alldata = format_calc_bytes(alldata,sha256val,CHKVAL_STRUCT_SHA256VAL_SIZE,CALC_SHA256_SIZE,sha256foff,True,'[%s].[%s].[%s][sha256]'%(incfile,objfile,funcname))
    alldata = format_calc_bytes(alldata,sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,CALC_SHA3_SIZE,sha3foff,True,'[%s].[%s].[%s][sha3]'%(incfile,objfile,funcname))
    alldata = format_calc_bytes(alldata,'%x'%(setoffset),CHKVAL_STRUCT_OFFSET_SIZE,CALC_OFFSET_SIZE,offsetfoff,False,'[%s].[%s].[%s][offset]'%(incfile,objfile,funcname))
    alldata = format_calc_bytes(alldata,'%x'%(len(relocs)),CHKVAL_STRUCT_SIZE_SIZE,CALC_SIZE_SIZE,sizefoff,False,'[%s].[%s].[%s][size]'%(incfile,objfile,funcname))


    # now we should get the 
    return odict,alldata

def chkval_fill_inc_obj(args,objparser,exefile,alldata,odict,incfile,objfile,basefuncoff,win32mode):
    funcs = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,objfile)
    if funcs is not None:
        for f in funcs.keys():
            odict,alldata = chkval_fill_inc_obj_func(args,objparser,exefile,alldata,odict,incfile,objfile,f,basefuncoff,win32mode)
    else:
        logging.warn('[%s] not get functions'%(objfile))
    return odict,alldata

def chkval_fill_inc_lastitem(args,objparser,exefile,alldata,odict,incfile,win32mode):
    funcodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_STRUCT_LASTONE)
    assert(funcodict is not None)
    sizedata = get_odict_value(funcodict,CHKVAL_STRUCT_SIZE)
    relocs = zero_bytes(len(sizedata))
    realf = CHKVAL_STRUCT_LASTONE
    if win32mode:
        realf = '_%s'%(realf)
    foff = objparser.get_text_file_off(sizedata,relocs,realf)
    assert(foff >= 0)
    zerobytes = format_bytes('0',CHKVAL_STRUCT_SIZE_SIZE,False)
    alldata = set_data_bytes(alldata,zerobytes,foff,'[%s].[%s]'%(incfile,CHKVAL_STRUCT_LASTONE))
    return odict,alldata

def get_value_check_offset(valuechecksdict,objparser,name):
    posdata = get_odict_value(valuechecksdict,name)
    posrelocs = zero_bytes(len(posdata))
    return objparser.get_text_file_off(posdata,posrelocs,name)

def get_function_name_offset(objparser,odict,objname,funcorig):
    funcname = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,objname,funcorig)
    assert(funcname is not None)
    posdict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,objname,funcname)
    assert(posdict is not None)
    posdata = get_odict_value(posdict,CHKVAL_RDATA_DATAS)
    posrelocs = get_odict_value(posdict,CHKVAL_RDATA_RELOCS)
    return objparser.get_text_file_off(posdata,posrelocs,funcorig)


def __inc_filled_self(args,objparser,exefile,alldata,odict,incfile,win32mode):
    # first to find the crc32_calc function and find 
    startoffdata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_FUNC_CHECKS_START)
    assert(startoffdata is not None)
    startoffrel = zero_bytes(len(startoffdata))
    startoff = objparser.get_text_file_off(startoffdata, startoffrel,CHKVAL_FUNC_CHECKS_START)
    assert(startoff >= 0)
    endoffdata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_FUNC_CHECKS_END)
    assert(endoffdata is not None)
    endoffrel = zero_bytes(len(endoffdata))
    endoff = objparser.get_text_file_off(endoffdata,endoffrel,CHKVAL_FUNC_CHECKS_END)
    assert(endoff >= 0)
    assert(endoff >= startoff)
    totalenddata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_VALUE_CHECKS_TOTAL_END)
    assert(totalenddata is not None)
    totalendoffrel = zero_bytes(len(totalenddata))
    totalendoff = objparser.get_text_file_off(totalenddata,totalendoffrel,CHKVAL_VALUE_CHECKS_TOTAL_END)
    assert(totalendoff >= 0)
    assert(totalendoff >= endoff)

    realdata = alldata[startoff:endoff]
    crc32val = get_crc32_value(realdata)
    md5val = get_md5_value(realdata)
    sha256val = get_sha256_value(realdata)
    sha3val = get_sha3_value(realdata)

    valuechecksdict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_VALUE_CHECKS)
    assert(valuechecksdict is not None)
    crc32pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_CRC32VAL)
    md5pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_MD5VAL)
    sha256pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_SHA256VAL)
    sha3pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_SHA3VAL)
    sizepos = get_value_check_offset(valuechecksdict,objparser, CHKVAL_STRUCT_SIZE)

    alldata = format_calc_bytes(alldata,crc32val,CHKVAL_STRUCT_CRC32VAL_SIZE,CALC_CRC32_SIZE,crc32pos,False,'[%s].chkval.[crc32]'%(incfile))
    alldata = format_calc_bytes(alldata,md5val,CHKVAL_STRUCT_MD5VAL_SIZE,CALC_MD5_SIZE,md5pos, True,'[%s].chkval.[md5]'%(incfile))
    alldata = format_calc_bytes(alldata,sha256val,CHKVAL_STRUCT_SHA256VAL_SIZE,CALC_SHA256_SIZE, sha256pos,True,'[%s].chkval.[sha256]'%(incfile))
    alldata = format_calc_bytes(alldata,sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,CALC_SHA3_SIZE,sha3pos,True,'[%s].chkval.[sha3]'%(incfile))

    # to get the position for the sha3 code of the functions
    namexor1pos = get_value_check_offset(valuechecksdict, objparser, CHKVAL_STRUCT_NAMEXOR1)
    startfuncpos = get_function_name_offset(objparser,odict,incfile,CHKVAL_START_FUNCTION_NAME)
    endfuncpos = get_function_name_offset(objparser,odict,incfile,CHKVAL_END_FUNCTION_NAME)
    realdata = alldata[startfuncpos:endfuncpos]
    sha3val = get_sha3_value(realdata)
    sha3bytes = format_bytes(sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,True)
    alldata = set_data_bytes(alldata,sha3bytes,namexor1pos)

    realdata = []
    realdata.extend(alldata[startoff:totalendoff])
    sizebytes = zero_bytes(CHKVAL_STRUCT_SIZE_SIZE)
    # clear the bytes ,and it will give clear
    realdata = set_data_bytes(realdata,sizebytes, (sizepos - startoff))
    logging.info('sizepos [0x%x:%d]realdata checked\n%s'%((sizepos - startoff),(sizepos - startoff),format_bytes_debug(realdata)))
    crcval = get_crc_sum(realdata)
    logging.info('crcval 0x%x'%(crcval))
    # now we should make change
    crcval = 0x100000000 - crcval
    # not overflow
    crcval = crcval & 0xffffffff
    crcbytes = format_bytes('%x'%(crcval), 4 , False)
    # to search for the position
    setpos = (sizepos - startoff)
    while (setpos % 4) != 0:
        setpos += 1
    logging.info('crcbytes %s'%(crcbytes))
    realdata = set_data_bytes(realdata,crcbytes, setpos)
    alldata = set_data_bytes(alldata, realdata,startoff)

    return odict,alldata

def chkval_fill_inc(args,objparser,exefile,alldata,odict,incfile,win32mode):
    incodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,incfile)
    basefuncname = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,incfile,CHKVAL_BASE_FUNCTION_NAME)
    logging.info('basefuncname [%s]'%(basefuncname))
    assert(basefuncname is not None)
    assert(incodict is not None)
    basefuncodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,incfile,basefuncname)
    assert(basefuncodict is not None)
    basefuncdata = get_odict_value(basefuncodict,CHKVAL_RDATA_DATAS)
    basefuncrelocs = get_odict_value(basefuncodict, CHKVAL_RDATA_RELOCS)
    realf = basefuncname
    if win32mode:
        realf = '_%s'%(basefuncname)
    basefuncoff = objparser.get_text_file_off(basefuncdata,basefuncrelocs,realf)
    logging.info('basefuncoff 0x%x'%(basefuncoff))
    assert(basefuncoff >= 0)
    for o in incodict.keys():
        logging.debug('o[%s]'%(o))
        odict,alldata = chkval_fill_inc_obj(args,objparser,exefile,alldata,odict,incfile,o,basefuncoff,win32mode)
    odict, alldata = chkval_fill_inc_lastitem(args,objparser,exefile,alldata,odict,incfile,win32mode)
    odict,alldata = __inc_filled_self(args,objparser,exefile,alldata,odict,incfile,win32mode)
    return odict,alldata

def chkval_fill_data(args,objtype,odict,exefile,chkobjs=[],win32mode=False):
    objparser = call_object_parser(objtype,exefile)
    alldata = objparser.get_data()
    for f in chkobjs:
        logging.debug('f[%s]'%(f))
        odict,alldata = chkval_fill_inc(args,objparser,exefile,alldata,odict,f,win32mode)
    objparser.close()
    write_file_ints(alldata, exefile)
    return odict

##extractcode_end