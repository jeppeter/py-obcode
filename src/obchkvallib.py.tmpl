#! /usr/bin/env python

import logging
import os
import sys
import re
import random
import zlib
import sha3
import hashlib
from Crypto.Cipher import AES


sys.path.append(os.path.abspath(os.path.dirname(__file__)))
from strparser import *
from jsonhdl import *
from cobfilebase import *


##extractcode_start

C_CODE_CRC32CALC='''%C_CODE_CRC32CALC%'''
C_CODE_MD5CALC='''%C_CODE_MD5CALC%'''
C_CODE_SHA256CALC='''%C_CODE_SHA256CALC%'''
C_CODE_SHA3CALC='''%C_CODE_SHA3CALC%'''
C_CODE_CHKVALDEF='''%C_CODE_CHKVALDEF%'''
C_CODE_CHKVAL='''%C_CODE_CHKVAL%'''
C_CODE_AES='''%C_CODE_AES%'''


class ChkVal(COBFileBase):
    def __init__(self,sfile,dfile=None,cfg=None):
        COBFileBase.__init__(self,sfile,dfile,cfg)
        self.__ob_random_name_expr = re.compile('.*(OB_RANDOM_NAME\s*(\(.*))$')
        self.__ob_random_name_spec_expr = re.compile('.*(OB_RANDOM_NAME_SPEC\s*(\(.*))$')
        self.__ob_chkval_func_expr = re.compile('.*(OB_CHKVAL_FUNC\s*(\(.*))$')
        self.__ob_chkval_func_spec_expr = re.compile('.*(OB_CHKVAL_FUNC_SPEC\s*(\(.*))$')
        self.__ob_expand_code_expr = re.compile('\s+(OB_EXPAND_CODE\s*(\\\x28.*))$')
        self.__ob_expand_code_spec_expr = re.compile('\s+(OB_EXPAND_CODE_SPEC\s*(\\\x28.*))$')
        self.__ob_chkval_total_func_expr = re.compile('.*(OB_CHKVAL_TOTAL_FUNC\s*(\(.*))$')
        self.__ob_chkval_total_func_spec_expr = re.compile('.*(OB_CHKVAL_TOTAL_FUNC_SPEC\s*(\(.*))$')
        return

    def __format_ob_random_name_inner(self,objname,odict,cfg,params,before,after):
        assert(len(params) == 1)
        bs = string_to_ints(params[0])
        bs.insert(0,ord('"'))
        bs.append(ord('"'))
        sbyte,lbyte = parse_string(bs)
        assert(len(lbyte) <= 1)
        if len(lbyte) > 0 :
            assert(lbyte[0] == 0)
        rs = ints_to_string(sbyte)

        rndname = None
        if objname is not None and odict is not None:
            rndname = get_odict_value(odict,RANDOM_VARIABLE,objname,rs)
        if rndname is None:
            rndname = get_random_name(random.randint(cfg.namemin,cfg.namemax))
            if objname is not None and odict is not None:
                odict = set_odict_value(odict,rndname,RANDOM_VARIABLE,objname,rs)
            #odict[RANDOM_VARIABLE][objname][rs] = get_random_name(random.randint(cfg.namemin,cfg.namemax))
        newc = before
        newc += rndname
        newc += after
        return newc,odict


    def __format_ob_random_name_func(self,l,objname,odict):
        cfg , params, before ,after = self.get_variables(l, self.__ob_random_name_expr)
        return self.__format_ob_random_name_inner(objname,odict,cfg,params,before,after)

    def __format_ob_random_name_spec_func(self,l,objname,odict):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_mixed_str_spec_expr)
        return self.__format_ob_random_name_inner(objname,odict,cfg,params,before,after)

    def __format_c_line(self,origc,objname,odict):
        newc = origc        
        # now we should get the
        while True:
            if self.get_filter_expr_not_defined(newc,self.__ob_random_name_expr):
                newc, odict = self.__format_ob_random_name_func(newc,objname,odict)
            elif self.get_filter_expr_not_defined(newc,self.__ob_random_name_spec_expr):
                newc, odict = self.__format_ob_random_name_spec_func(newc,objname,odict)
            else:
                break
        return newc,odict

    def __format_multi_lines(self,mlines,objname,odict):
        rets = ''
        sarr = re.split('\n',mlines)
        for l in sarr:
            l = l.rstrip('\r\n')
            r , odict = self.__format_c_line(l,objname,odict)
            rets += '%s\n'%(r)
        return rets,odict

    def __format_char_array(self,odict,num,*path):
        name = get_odict_value(odict,RANDOM_VARIABLE,*path)
        if name is None:
            name = get_random_name(20)
            odict = set_odict_value(odict,name, RANDOM_VARIABLE,*path)

        sarr = get_odict_value(odict,CHKVAL_OBJ_DATA,*path)
        if sarr is None:
            sarr = get_random_bytes(num)
            odict = set_odict_value(odict,sarr,CHKVAL_OBJ_DATA,*path)

        rets = format_line('unsigned char %s[%d]={%s};'%(name,num,format_bytes_c(sarr)), 0)
        return rets,odict


    def __get_ll_value(self,sarr):
        llval = 0
        idx = 0
        while idx < len(sarr):
            llval += (sarr[idx] << (idx * 8))
            idx += 1
        return llval


    def __format_sarr_struct(self,odict,name,size,tabs,lastone,*path):
        rets = ''
        sarr = get_odict_value(odict,*path)
        if sarr is None:
            sarr = get_random_bytes(size)
            odict = set_odict_value(odict,sarr,*path)
        rets += format_debug_line('%s'%(name),tabs + 1, 3)
        if lastone:
            rets += format_line('{%s}'%(format_bytes_c(sarr)), tabs + 1)
        else:
            rets += format_line('{%s},'%(format_bytes_c(sarr)), tabs + 1)
        return rets, odict


    def __format_check_value_single(self,odict,f,tabs,lastone,*path):
        rets = ''
        rets += format_line('{', tabs)
        rets += format_debug_line('function %s'%(f), tabs + 1, 3)
        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_OFFSET)
        sarr = get_odict_value(odict,*curpath)
        if sarr is None:
            sarr = get_random_bytes(CHKVAL_STRUCT_OFFSET_SIZE)
            odict = set_odict_value(odict,sarr, *curpath)
        rets += format_debug_line('%s'%(CHKVAL_STRUCT_OFFSET),tabs+1,3)
        llval = self.__get_ll_value(sarr)
        rets += format_line('(signed long long) OB_LL_VALUE(0x%x),'%(llval), tabs+1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SIZE)
        sarr = get_odict_value(odict,*curpath)
        if sarr is None:
            sarr = get_random_bytes(CHKVAL_STRUCT_SIZE_SIZE)
            odict = set_odict_value(odict,sarr,*curpath)
        llval = self.__get_ll_value(sarr)
        rets += format_debug_line(' %s value'%(CHKVAL_STRUCT_SIZE),tabs+1,3)
        rets += format_line('(unsigned long long) OB_ULL_VALUE(0x%x),'%(llval), tabs + 1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_CRC32VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_CRC32VAL,CHKVAL_STRUCT_CRC32VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SHA256VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_SHA256VAL,CHKVAL_STRUCT_SHA256VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_NAMEXOR1)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_NAMEXOR1,CHKVAL_STRUCT_NAMEXOR1_SIZE,tabs,False,*curpath)
        rets += curs

        sarr1 = get_odict_value(odict,*curpath)
        assert(sarr1 is not None)
        namexors = string_to_ints(f)
        if len(namexors) >= CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors = namexors[:(CHKVAL_STRUCT_NAMEXOR1_SIZE-1)]
        if len(namexors) < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors.append(0)
        while len(namexors) < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            namexors.append(random.randint(0,255))
        sarr2 = []
        idx = 0
        while idx < CHKVAL_STRUCT_NAMEXOR2_SIZE:
            sarr2.append(0)
            idx += 1

        idx = 0
        while idx < CHKVAL_STRUCT_NAMEXOR1_SIZE:
            sarr2[idx] = namexors[idx] ^ sarr1[idx]
            idx += 1
        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_NAMEXOR2)
        odict = set_odict_value(odict,sarr2, *curpath)
        rets += format_debug_line('%s'%(CHKVAL_STRUCT_NAMEXOR2), tabs+ 1, 3)
        rets += format_line('{%s},'%(format_bytes_c(sarr2)), tabs+1)

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_SHA3VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_SHA3VAL,CHKVAL_STRUCT_SHA3VAL_SIZE,tabs,False,*curpath)
        rets += curs

        curpath = []
        curpath.extend(path)
        curpath.append(CHKVAL_STRUCT_MD5VAL)
        curs , odict = self.__format_sarr_struct(odict,CHKVAL_STRUCT_MD5VAL,CHKVAL_STRUCT_MD5VAL_SIZE,tabs,True,*curpath)
        rets += curs

        if lastone:
            rets += format_line('}', tabs)
        else:
            rets += format_line('},', tabs)
        return rets,odict


    def __format_check_value(self,odict,objname,o,chkfuncs=[]):
        odict = create_odict_is_none(odict,CHKVAL_RANDOM_VALUE,objname,o)
        curs , odict = self.__format_char_array(odict,CHKVAL_AES_KEY_SIZE,objname,CHKVAL_FUNC_CHECKS_START)
        funcchecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)
        if funcchecks is None:
            funcchecks = get_random_name(20)
            odict = set_odict_value(odict,funcchecks, RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)

        idx = 0
        for f in chkfuncs:
            curs, odict = self.__format_check_value_single(odict,f,1,False,CHKVAL_RANDOM_VALUE,objname,o,f)

        curs ,odict = self.__format_char_array(odict,CHKVAL_AES_IV_SIZE,objname,CHKVAL_FUNC_CHECKS_END)

        valuechecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)
        if valuechecks is None:
            valuechecks = get_random_name(20)
            odict = set_odict_value(odict,valuechecks, RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)

        curs , odict = self.__format_check_value_single(odict,CHKVAL_VALUE_CHECKS_DICT,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_VALUE_CHECKS)
        return odict

    def format_c_code_pre(self,args,odict,objname):
        #logging.info('objname [%s]'%(objname))
        odict = create_odict_is_none(odict, RANDOM_VARIABLE,objname)
        odict = create_odict_is_none(odict,CHKVAL_RANDOM_VALUE,objname)

        rets = ''

        curs , odict = self.__format_multi_lines(C_CODE_CHKVALDEF,objname,odict)
        rets += curs

        # we include the headers here ,because we could like to make 
        # CHKVAL_BASE_FUNCTION_NAME crc32_calc to be the first function 
        # in the .text sections
        rets += format_includes(args)

        curs,odict = self.__format_multi_lines(C_CODE_CRC32CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_MD5CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_SHA256CALC,objname,odict)
        rets += curs
        curs , odict = self.__format_multi_lines(C_CODE_SHA3CALC, objname,odict)
        rets += curs

        curs , odict = self.__format_multi_lines(C_CODE_AES,objname,odict)
        rets += curs

        return rets,odict

    def format_c_code_post(self,odict,objname):
        rets= ''        
        #logging.info('objname [%s]'%(objname))
        curs, odict = self.__format_multi_lines(C_CODE_CHKVAL,objname,odict)
        rets += curs
        return rets,odict

    def __write_check_value(self,odict,objname,jdict):
        rets = ''
        curs , odict = self.__format_char_array(odict,CHKVAL_AES_KEY_SIZE,objname,CHKVAL_FUNC_CHECKS_START)
        rets += curs

        func_checks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_FUNC_CHECKS)
        assert(func_checks is not None)

        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('extern "C" {', 0)
        rets += format_line('#endif', 0)

        rets += format_line('',0)
        rets += format_line('chkvalue_t %s[] = {'%(func_checks), 0)

        for o in jdict.keys():
            chkfuncs = jdict[o]
            for f in chkfuncs:
                curs, odict = self.__format_check_value_single(odict,f,1,False,CHKVAL_RANDOM_VALUE,objname,o,f)
                rets += curs

        #curs,odict = self.__format_check_value_single(odict,'',1,True,CHKVAL_RANDOM_VALUE,objname,CHKVAL_STRUCT_LASTONE,'')
        curs,odict = self.__format_check_value_single(odict,CHKVAL_STRUCT_LASTONE,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_STRUCT_LASTONE)
        rets += curs
        rets += format_line('};', 0)

        rets += format_line('', 0)
        curs ,odict = self.__format_char_array(odict,CHKVAL_AES_IV_SIZE,objname,CHKVAL_FUNC_CHECKS_END)
        rets += curs

        rets += format_line('', 0)

        valuechecks = get_odict_value(odict,RANDOM_VARIABLE,objname,CHKVAL_VALUE_CHECKS)
        assert(valuechecks is not None)
        rets += format_line('chkvalue_t %s[1] = {'%(valuechecks),0)
        curs , odict = self.__format_check_value_single(odict,CHKVAL_VALUE_CHECKS_DICT,1,True,CHKVAL_OBJ_DATA,objname,CHKVAL_VALUE_CHECKS)
        rets += curs
        rets += format_line('};',0)

        curs,odict = self.__format_char_array(odict,16,objname,CHKVAL_VALUE_CHECKS_TOTAL_END)
        rets += curs

        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('};', 0)
        rets += format_line('#endif', 0)
        return rets



    def format_c_code(self,odict, objname,jdict):

        # this to check value
        #logging.info('objname [%s]'%(objname))
        rets = ''
        for k in jdict.keys():
            #logging.info('k [%s]'%(k))
            odict = self.__format_check_value(odict,objname,k,jdict[k])
        #logging.info(' ')
        rets = self.__write_check_value(odict,objname,jdict)
        return rets,odict

    def output_chkval_func(self,funcname,objname,functype,tabs=0):
        rets = ''
        if funcname is not None:
            rets += format_line('',tabs)
            rets += format_debug_line(' %s %s func'%(objname,functype), tabs, 3)
            rets += format_line('int %s(m_check_fail_func_t failfunc);'%(funcname),tabs)
        return rets

    def __set_retodict(self,odict,retodict,objname,functype):
        func = get_odict_value(odict,RANDOM_VARIABLE,objname,functype)
        if func is not None:
            if objname not in retodict.keys():
                retodict[objname] = dict()
            retodict[objname][functype] = func
        return retodict


    def get_functions_odict(self,odict,objs):
        retodict=dict()
        for o in objs:
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_CRC32_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_MD5_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_SHA256_FUNC)
            retodict = self.__set_retodict(odict,retodict,o,CHKVAL_FUNC_CHECK_SHA3_FUNC)
        return retodict

    def format_chkval_header(self,odict,objs=[]):
        pregaurd = '__%s__'%(get_random_name(30))
        rets = ''
        rets += format_line('#ifndef %s'%(pregaurd),0)
        rets += format_line('#define %s'%(pregaurd),0)
        rets += format_line('',0)
        rets += format_line('#include <obcode.h>',0)
        rets += format_line('',0)
        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('extern "C" {', 0)
        rets += format_line('#endif /*__cplusplus*/',0)
        rets += format_line('',0)

        for o in objs:
            #logging.info('o[%s]'%(o))
            crc32func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_CRC32_FUNC)
            md5func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_MD5_FUNC)
            sha256func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_SHA256_FUNC)
            sha3func = get_odict_value(odict,RANDOM_VARIABLE,o,CHKVAL_FUNC_CHECK_SHA3_FUNC)
            rets += self.output_chkval_func(crc32func,o,'crc32')
            rets += self.output_chkval_func(md5func,o,'md5')
            rets += self.output_chkval_func(sha256func,o,'sha256')
            rets += self.output_chkval_func(sha3func,o,'sha3')

        rets += format_line('',0)
        rets += format_line('#ifdef __cplusplus',0)
        rets += format_line('};', 0)
        rets += format_line('#endif /*__cplusplus*/',0)
        rets += format_line('',0)
        rets += format_line('#endif /*%s*/'%(pregaurd),0)
        return rets

    def __format_ob_chkval_func_inner(self,l,retodict,cfg,params,before,after):
        idx = -1
        if len(retodict['FUNCS']) > 0:
            idx = random.randint(0,len(retodict['FUNCS']) - 1)
        #logging.info('idx [%d]'%(idx))
        if idx < 0:
            # we do not have the functions ,so just keep 
            return '%s\n'%(l)
        typecall = retodict['TYPES'][idx]
        file = retodict['FILES'][idx]
        funcname = retodict['FUNCS'][idx]
        tabs = count_tabs(l)
        rets = ''
        rets += format_debug_line(' in [%s] for [%s] '%(file,typecall),tabs,3)
        rets += format_line('#line %d'%(self.cur_line),0)
        rets += before
        rets += '%s(%s)'%(funcname,params[0])
        rets += after
        rets += '\n'
        return rets



    def __format_ob_chkval_func(self,l,retodict):
        cfg ,params,before ,after = self.get_variables(l,self.__ob_chkval_func_expr)
        return self.__format_ob_chkval_func_inner(l,retodict,cfg,params,before,after)

    def __format_ob_chkval_func_spec(self,l,retodict):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_chkval_func_spec_expr)
        return self.__format_ob_chkval_func_inner(l,retodict,cfg,params,before,after)

    def __format_ob_chkval_total_func_inner(self,l,retodict,cfg,params,before,after):
        idx = -1
        jdx = -1
        if len(retodict['FUNCS']) > 0:
            idx = random.randint(0,len(retodict['FUNCS']) - 1)
        if len(retodict['FAILFUNC']) > 0:
            jdx = random.randint(0,len(retodict['FAILFUNC']) - 1)
        #logging.info('idx [%d]'%(idx))
        if idx < 0 or jdx < 0:
            # we do not have the functions ,so just keep 
            return '%s\n'%(l)
        typecall = retodict['TYPES'][idx]
        file = retodict['FILES'][idx]
        funcname = retodict['FUNCS'][idx]
        failfunc = retodict['FAILFUNC'][jdx]
        tabs = count_tabs(l)
        rets = ''
        rets += format_debug_line(' in [%s] for [%s] '%(file,typecall),tabs,3)
        rets += format_line('#line %d'%(self.cur_line),0)
        rets += before
        rets += '%s(%s)'%(funcname,failfunc)
        rets += after
        rets += '\n'
        return rets



    def __format_ob_chkval_total_func(self,l,retodict):
        cfg ,params,before ,after = self.get_variables(l,self.__ob_chkval_total_func_expr)
        return self.__format_ob_chkval_total_func_inner(l,retodict,cfg,params,before,after)

    def __format_ob_chkval_total_func_spec(self,l,retodict):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_chkval_total_func_spec_expr)
        return self.__format_ob_chkval_total_func_inner(l,retodict,cfg,params,before,after)


    def __format_ob_expand_code_inner(self,l,params,cfg,before,after):
        rets = ''
        rets += self.expand_code(l,params,cfg,before,after)
        #rets += format_line('#line %d'%(self.cur_line),0)
        rets += format_line('%s'%(l),0)
        return rets

    def __format_ob_expand_code(self,l):
        cfg ,params,before ,after = self.get_variables(l,self.__ob_expand_code_expr)
        return self.__format_ob_expand_code_inner(l,params,cfg,before,after)

    def __format_ob_expand_code_spec(self,l):
        cfg ,params,before ,after = self.get_spec_config_variables(l,self.__ob_chkval_func_spec_expr)
        return self.__format_ob_expand_code_inner(l,params,cfg,before,after)

    def get_failfunc_objects(self,odict,exitobjs=[],failfunc=''):
        failfuncs = []
        for f in exitobjs:
            curfunc = get_odict_value(odict,RANDOM_VARIABLE,f,failfunc)
            if curfunc is not None:
                failfuncs.append(curfunc)
        return failfuncs


    def replace_functions(self,odict,objs=[],exitobjs=[],failfunc=''):
        #logging.info('objs %s'%(objs))
        retodict = self.get_functions_odict(odict,objs)
        funccalls = []
        funcnames = []
        funcfiles = []
        for k in retodict.keys():
            for v in retodict[k].keys():
                funccalls.append(retodict[k][v])
                funcnames.append(v)
                funcfiles.append(k)
        failfuncs = self.get_failfunc_objects(odict,exitobjs,failfunc)
        retodict = dict()
        retodict['FILES'] = funcfiles
        retodict['FUNCS'] = funccalls
        retodict['TYPES'] = funcnames
        retodict['FAILFUNC'] = failfuncs
        rets = ''
        self.cur_line = 0
        for l in self.in_lines:
            self.cur_line += 1
            l = l.rstrip('\r\n')
            #logging.debug('[%d][%s]'%(self.cur_line, l))
            if self.get_filter_expr_not_defined(l,self.__ob_chkval_func_expr):
                rets += self.__format_ob_chkval_func(l,retodict)
            elif self.get_filter_expr_not_defined(l, self.__ob_chkval_func_spec_expr):
                rets += self.__format_ob_chkval_func_spec(l,retodict)
            elif self.get_filter_expr_not_defined(l, self.__ob_chkval_total_func_expr):
                rets += self.__format_ob_chkval_total_func(l,retodict)
            elif self.get_filter_expr_not_defined(l, self.__ob_chkval_total_func_spec_expr):
                rets += self.__format_ob_chkval_total_func_spec(l,retodict)
            elif self.get_filter_expr_not_defined(l, self.__ob_expand_code_expr):
                rets += self.__format_ob_expand_code(l)
            elif self.get_filter_expr_not_defined(l,self.__ob_expand_code_spec_expr):
                rets += self.__format_ob_expand_code_spec(l)
            else:
                rets += '%s\n'%(l)
        return rets


    def expand_chkval_code(self,objname=None,odict=None):
        self.cur_line = 0
        rets = ''
        for l in self.in_lines:
            self.cur_line += 1
            l = l.rstrip('\r\n')
            #logging.info('[%d][%s]'%(self.cur_line, l))
            if self.get_filter_expr_not_defined(l,self.__ob_expand_code_expr):
                rets += self.__format_ob_expand_code(l)
            elif self.get_filter_expr_not_defined(l,self.__ob_expand_code_spec_expr):
                rets += self.__format_ob_expand_code_spec(l)
            elif self.get_filter_expr_not_defined(l,self.__ob_random_name_expr) or self.get_filter_expr_not_defined(l,self.__ob_random_name_spec_expr):
                curs,odict = self.__format_c_line(l,objname,odict)
                rets += curs
            else:
                rets += '%s\n'%(l)
        return rets,odict


def chkval_dump_object_function_one(args,objparser,odict,o,f,win32mode=False):
    #logging.info('o[%s]f[%s]'%(o,f))
    fodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,o,f)
    realf = f
    if win32mode:
        realf = '_%s'%(f)
    if fodict is None:
        fodict = dict()
        fvaddr = objparser.func_vaddr(realf)
        foff = objparser.func_offset(realf)
        fsize = objparser.func_size(realf)
        if fvaddr < 0 or fsize < 0 or foff < 0:
            raise Exception('can not find [%s](%s) in [%s]'%(f,realf,o))
        alldata = objparser.get_data()
        relocs = []
        # just read the code ,and this is to search for the coding
        idx = 0
        while idx < fsize:
            relocs.append(objparser.is_in_reloc(fvaddr+idx,realf))
            idx += 1
        fodict = set_odict_value(fodict,alldata[foff:(foff + fsize)],CHKVAL_RDATA_DATAS)
        fodict = set_odict_value(fodict,relocs,CHKVAL_RDATA_RELOCS)
        odict = set_odict_value(odict,fodict,CHKVAL_KEY, CHKVAL_RAW_DATA,o,f)
    return odict

def chkval_dump_check_functions(args,objtype,odict,outname,win32mode=False):
    #logging.debug('[%s]'%(outname))
    startfunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_START_FUNCTION_NAME)
    endfunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_END_FUNCTION_NAME)
    basefunc = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_BASE_FUNCTION_NAME)
    valuechkes = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,outname,CHKVAL_VALUE_CHECKS)
    assert(startfunc is not None)
    assert(endfunc is not None)
    assert(basefunc is not None)
    objparser = call_object_parser(objtype,outname)
    odict = chkval_dump_object_function_one(args,objparser,odict,outname, startfunc,win32mode)
    odict = chkval_dump_object_function_one(args,objparser, odict,outname, endfunc, win32mode)
    odict = chkval_dump_object_function_one(args,objparser, odict,outname, basefunc, win32mode)
    odict = chkval_dump_object_function_one(args,objparser,odict,outname, valuechkes, win32mode)
    objparser.close()
    objparser = None
    return odict

def chkval_dump_object_functions(args,objtype,odict,objs=[],win32mode=False):
    rval = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,args.output)
    if rval is not None:
        for o in objs:
            curobjparser= call_object_parser(objtype,o)
            rval = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,args.output,o)
            if rval is None:
                logging.warn('can not get [%s]'%(o))
                continue
            for f in rval.keys():
                odict = chkval_dump_object_function_one(args,curobjparser,odict,o,f,win32mode)
            curobjparser.close()
    else:
        logging.warn('[%s]None handle'%(args.output))

    # now we should get the output function value
    odict = chkval_dump_check_functions(args,objtype,odict,args.output,win32mode)
    return odict

def chkval_get_realdata(objparser,exefile,odict,rawdata,objname,funcname,win32mode):
    realdata = []
    realdata.extend(rawdata)
    exeodict = get_odict_value(odict,PATCH_FUNC_KEY,exefile,objname,funcname)
    logging.info('exeodict %s'%(exeodict))
    if exeodict is not None:
        # this is patched, so we should give this to the xors
        offsetk = get_odict_value(exeodict,FORMAT_FUNC_OFFSET_KEY)
        logging.debug('offsetk %s'%(offsetk))
        xors = get_odict_value(exeodict,FORMAT_FUNC_XORS_KEY)
        relocs = get_odict_value(exeodict,FUNC_DATA_RELOC_KEY)
        assert(offsetk is not None)
        assert(xors is not None)
        for offk in offsetk.keys():
            offi = int(offk)
            # this means we relocs , so we change the value
            if offsetk[offk] >= 2 :
                logging.debug('[%s].[%s].[0x%x:%d] [0x%02x] ^ [0x%02x] = [0x%02x]'%(objname,funcname,offi,offi,realdata[offi],xors[offk],(realdata[offi] ^ xors[offk])))
                realdata[offi] = realdata[offi] ^ xors[offk]
            else:
                logging.debug('[%s].[%s].[0x%x:%d] nothing handle [0x%02x]'%(objname,funcname, offi,offi,realdata[offi]))
    return realdata

def chkval_cfiles(args,odict,*path):
    d = args.appendpath
    d = os.path.abspath(d)
    files = get_odict_value(odict,CHKVAL_KEY,*path)
    if files is None:
        fnum = args.chkval_times
        files = []
        if fnum == 0:
            fnum = random.randint(4,10)
        idx = 0
        while idx < fnum:
            curname = '%s.%s'%(get_random_name(random.randint(10,20)),args.csuffix)
            curname = os.path.join(d,curname)
            if os.path.exists(curname) or curname in files:
                continue
            files.append(curname)
            idx += 1
        odict = set_odict_value(odict,files , CHKVAL_KEY,*path)
        write_json(odict,args.dump)
    return files


def chkval_objs(args,odict,*path):
    files = chkval_cfiles(args,odict,*path)
    objs = []
    for f in files:
        if args.objpattern is not None and args.cpattern is not None:
            f = re.sub(args.cpattern,args.objpattern,f)
        o = re.sub('\.%s$'%(args.csuffix), '.%s'%(args.objsuffix),f)
        objs.append(o)
    return objs


def chkval_exit_files(args,odict,keyval):
    return chkval_cfiles(args,odict,CHKVAL_EXIT_HANDLER_FILES,keyval)

def chkval_exit_objs(args,odict,keyval):
    return chkval_objs(args,odict,CHKVAL_EXIT_HANDLER_FILES,keyval)

def chkval_data_files(args,odict,keyval):
    return chkval_cfiles(args,odict,CHKVAL_DATA_FILES,keyval)

def chkval_data_objs(args,odict,keyval):
    return chkval_objs(args,odict,CHKVAL_DATA_FILES,keyval)

def get_crc32_value(rawdata):
    crc32val = zlib.crc32(ints_to_bytes(rawdata))
    if crc32val < 0:
        crc32val = (1 << 32) + crc32val
    return '%x'%(crc32val)

def get_md5_value(rawdata):
    m = hashlib.md5()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_sha256_value(rawdata):
    m = hashlib.sha256()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_sha3_value(rawdata):
    m = sha3.sha3_512()
    m.update(ints_to_bytes(rawdata))
    return m.hexdigest()

def get_crc_sum(rawdata):
    idx = 0
    crcval = 0
    size = len(rawdata)
    curval = 0
    while idx < size:
        curval = 0
        jdx = 0
        while jdx < (size - idx) and jdx < 4:
            curval += ((rawdata[(idx + jdx)]) << (jdx * 8))
            jdx += 1
        crcval += curval
        # not overflow
        crcval = crcval & 0xffffffff
        idx += 4
    return crcval

def format_calc_bytes(alldata,val,storesize,calcsize,pos,bigendian=False,note=''):
    b = format_bytes(val,calcsize,bigendian)
    assert(calcsize <= storesize)
    if storesize > calcsize:
        b.extend(get_random_bytes(storesize - calcsize))
    return set_data_bytes(alldata,b,pos,note)

def get_store_value_obj_func(args,objparser,alldata,odict,exefile,objfile,funcname, win32mode):
    funcodict = get_odict_value(odict,CHKVAL_STORE_VALUE,objfile,funcname)
    if funcodict is None:
        funcodict = dict()
        datas = get_odict_value(odict, CHKVAL_KEY,CHKVAL_RAW_DATA,objfile,funcname,CHKVAL_RDATA_DATAS)
        relocs = get_odict_value(odict, CHKVAL_KEY,CHKVAL_RAW_DATA,objfile,funcname,CHKVAL_RDATA_RELOCS)
        realf = funcname
        if win32mode:
            realf = '_%s'%(funcname)
        foff = objparser.get_text_file_off(datas,relocs,realf)
        rawdata = alldata[foff:(foff + len(relocs))]
        realdata = chkval_get_realdata(objparser,exefile,odict,rawdata,objfile,funcname,win32mode)
        
        logging.info('%s'%(format_bytes_debug(rawdata,'rawdata [%s].[%s].[%s]'%(exefile,objfile,funcname))))
        logging.info('%s'%(format_bytes_debug(realdata,'realdata [%s].[%s].[%s]'%(exefile,objfile,funcname))))
        crc32val = get_crc32_value(realdata)
        md5val = get_md5_value(realdata)
        sha256val = get_sha256_value(realdata)
        sha3val = get_sha3_value(realdata)

        funcodict = set_odict_value(funcodict,crc32val,CHKVAL_STRUCT_CRC32VAL)
        funcodict = set_odict_value(funcodict, md5val, CHKVAL_STRUCT_MD5VAL)
        funcodict = set_odict_value(funcodict, sha256val, CHKVAL_STRUCT_SHA256VAL)
        funcodict = set_odict_value(funcodict, sha3val, CHKVAL_STRUCT_SHA3VAL)
        funcodict = set_odict_value(funcodict, len(rawdata), CHKVAL_STRUCT_SIZE)
        funcodict = set_odict_value(funcodict, foff , CHKVAL_STRUCT_OFFSET)

        odict = set_odict_value(odict, funcodict, CHKVAL_STORE_VALUE,objfile,funcname)
    return odict


def chkval_fill_inc_obj_func(args,objparser,exefile,alldata,odict,incfile,objfile,funcname,basefuncoff, incobjparser,incdatas,incdatapos,win32mode):
    # now get the k value
    odict = get_store_value_obj_func(args,objparser,alldata,odict,exefile,objfile,funcname,win32mode)
    # now to get function store data
    rnddatadict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,incfile,objfile,funcname)
    realf = funcname
    if win32mode:
        realf = '_%s'%(funcname)
    assert(rnddatadict is not None)
    crc32rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_CRC32VAL)
    sha256rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SHA256VAL)
    sha3rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SHA3VAL)
    md5rnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_MD5VAL)
    sizernddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_SIZE)
    offsetrnddata = get_odict_value(rnddatadict,CHKVAL_STRUCT_OFFSET)


    crc32foff = incobjparser.get_text_file_off(crc32rnddata,zero_bytes(CHKVAL_STRUCT_CRC32VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_CRC32VAL),incdatas)
    sha256foff = incobjparser.get_text_file_off(sha256rnddata,zero_bytes(CHKVAL_STRUCT_SHA256VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SHA256VAL),incdatas)
    sha3foff = incobjparser.get_text_file_off(sha3rnddata,zero_bytes(CHKVAL_STRUCT_SHA3VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SHA3VAL),incdatas)
    md5foff = incobjparser.get_text_file_off(md5rnddata,zero_bytes(CHKVAL_STRUCT_MD5VAL_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_MD5VAL),incdatas)
    sizefoff = incobjparser.get_text_file_off(sizernddata,zero_bytes(CHKVAL_STRUCT_SIZE_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_SIZE),incdatas)
    offsetfoff = incobjparser.get_text_file_off(offsetrnddata,zero_bytes(CHKVAL_STRUCT_OFFSET_SIZE),'%s_%s'%(realf,CHKVAL_STRUCT_OFFSET),incdatas)

    funcodict = get_odict_value(odict, CHKVAL_STORE_VALUE,objfile, funcname)
    assert(funcodict is not None)

    crc32val = get_odict_value(funcodict,CHKVAL_STRUCT_CRC32VAL)
    md5val = get_odict_value(funcodict,CHKVAL_STRUCT_MD5VAL)
    sha256val = get_odict_value(funcodict,CHKVAL_STRUCT_SHA256VAL)
    sha3val = get_odict_value(funcodict,CHKVAL_STRUCT_SHA3VAL)
    foff = get_odict_value(funcodict,CHKVAL_STRUCT_OFFSET)
    size = get_odict_value(funcodict,CHKVAL_STRUCT_SIZE)
    if foff > basefuncoff:
        setoffset = foff - basefuncoff
    else:
        setoffset = basefuncoff - foff
        setoffset = (0x1 << 64) - setoffset

    incdatas = format_calc_bytes(incdatas,crc32val,CHKVAL_STRUCT_CRC32VAL_SIZE,CALC_CRC32_SIZE,crc32foff,False,'[%s].[%s].[%s][crc32]'%(incfile,objfile,funcname))
    incdatas = format_calc_bytes(incdatas,md5val,CHKVAL_STRUCT_MD5VAL_SIZE,CALC_MD5_SIZE,md5foff,True,'[%s].[%s].[%s][md5]'%(incfile,objfile,funcname))
    incdatas = format_calc_bytes(incdatas,sha256val,CHKVAL_STRUCT_SHA256VAL_SIZE,CALC_SHA256_SIZE,sha256foff,True,'[%s].[%s].[%s][sha256]'%(incfile,objfile,funcname))
    incdatas = format_calc_bytes(incdatas,sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,CALC_SHA3_SIZE,sha3foff,True,'[%s].[%s].[%s][sha3]'%(incfile,objfile,funcname))
    incdatas = format_calc_bytes(incdatas,'%x'%(setoffset),CHKVAL_STRUCT_OFFSET_SIZE,CALC_OFFSET_SIZE,offsetfoff,False,'[%s].[%s].[%s][offset]'%(incfile,objfile,funcname))
    incdatas = format_calc_bytes(incdatas,'%x'%(size),CHKVAL_STRUCT_SIZE_SIZE,CALC_SIZE_SIZE,sizefoff,False,'[%s].[%s].[%s][size]'%(incfile,objfile,funcname))

    alldata = set_data_bytes(alldata, incdatas, incdatapos)
    # now we should get the 
    return odict,alldata

def chkval_fill_inc_obj(args,objparser,exefile,alldata,odict,incfile,objfile,basefuncoff, incobjparser,incdatas,incdatapos,win32mode):
    funcs = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,objfile)
    if funcs is not None:
        for f in funcs.keys():
            odict,alldata = chkval_fill_inc_obj_func(args,objparser,exefile,alldata,odict,incfile,objfile,f,basefuncoff,incobjparser,incdatas,incdatapos,win32mode)
    else:
        logging.warn('[%s] not get functions'%(objfile))
    return odict,alldata

def chkval_fill_inc_lastitem(args,objparser,exefile,alldata,odict,incfile,win32mode):
    funcodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_STRUCT_LASTONE)
    assert(funcodict is not None)
    sizedata = get_odict_value(funcodict,CHKVAL_STRUCT_SIZE)
    relocs = zero_bytes(len(sizedata))
    realf = CHKVAL_STRUCT_LASTONE
    if win32mode:
        realf = '_%s'%(realf)
    foff = objparser.get_text_file_off(sizedata,relocs,realf)
    assert(foff >= 0)
    zerobytes = format_bytes('0',CHKVAL_STRUCT_SIZE_SIZE,False)
    alldata = set_data_bytes(alldata,zerobytes,foff,'[%s].[%s]'%(incfile,CHKVAL_STRUCT_LASTONE))
    return odict,alldata

def get_value_check_offset(valuechecksdict,objparser,name):
    posdata = get_odict_value(valuechecksdict,name)
    posrelocs = zero_bytes(len(posdata))
    return objparser.get_text_file_off(posdata,posrelocs,name)

def get_function_name_offset(objparser,odict,objname,funcorig):
    funcname = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,objname,funcorig)
    assert(funcname is not None)
    posdict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,objname,funcname)
    assert(posdict is not None)
    posdata = get_odict_value(posdict,CHKVAL_RDATA_DATAS)
    posrelocs = get_odict_value(posdict,CHKVAL_RDATA_RELOCS)
    return objparser.get_text_file_off(posdata,posrelocs,funcorig)


def __inc_filled_self(args,objparser,exefile,alldata,odict,incfile,win32mode):
    # first to find the crc32_calc function and find 
    startoffdata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_FUNC_CHECKS_START)
    assert(startoffdata is not None)
    startoffrel = zero_bytes(len(startoffdata))
    startoff = objparser.get_text_file_off(startoffdata, startoffrel,CHKVAL_FUNC_CHECKS_START)
    assert(startoff >= 0)
    endoffdata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_FUNC_CHECKS_END)
    assert(endoffdata is not None)
    endoffrel = zero_bytes(len(endoffdata))
    endoff = objparser.get_text_file_off(endoffdata,endoffrel,CHKVAL_FUNC_CHECKS_END)
    assert(endoff >= 0)
    assert(endoff >= startoff)
    totalenddata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_VALUE_CHECKS_TOTAL_END)
    assert(totalenddata is not None)
    totalendoffrel = zero_bytes(len(totalenddata))
    totalendoff = objparser.get_text_file_off(totalenddata,totalendoffrel,CHKVAL_VALUE_CHECKS_TOTAL_END)
    assert(totalendoff >= 0)
    assert(totalendoff >= endoff)

    realdata = alldata[startoff:endoff]
    # now we should give the encryption
    assert((len(realdata) % CHKVAL_AES_IV_SIZE) == 0)
    assert(len(startoffdata) == CHKVAL_AES_KEY_SIZE)
    # now we should get the aes key
    aesdata = realdata[CHKVAL_AES_KEY_SIZE:]
    aesbytes = ints_to_bytes(aesdata)
    ivdata = alldata[endoff:(endoff+CHKVAL_AES_IV_SIZE)]
    ivbytes = ints_to_bytes(ivdata)
    keydata = realdata[:CHKVAL_AES_KEY_SIZE]
    keybytes = ints_to_bytes(keydata)
    aes = AES.new(keybytes,AES.MODE_CBC,ivbytes)
    encbytes = aes.encrypt(aesbytes)
    assert(len(encbytes) == len(aesbytes))
    aesdata = bytes_to_ints(encbytes)
    realdata = set_data_bytes(realdata,aesdata,CHKVAL_AES_KEY_SIZE,'[%s]encrypted data'%(incfile))
    alldata = set_data_bytes(alldata, realdata, startoff)

    crc32val = get_crc32_value(realdata)
    md5val = get_md5_value(realdata)
    sha256val = get_sha256_value(realdata)
    sha3val = get_sha3_value(realdata)

    valuechecksdict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA,incfile,CHKVAL_VALUE_CHECKS)
    assert(valuechecksdict is not None)
    crc32pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_CRC32VAL)
    md5pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_MD5VAL)
    sha256pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_SHA256VAL)
    sha3pos = get_value_check_offset(valuechecksdict,objparser,CHKVAL_STRUCT_SHA3VAL)
    sizepos = get_value_check_offset(valuechecksdict,objparser, CHKVAL_STRUCT_SIZE)

    alldata = format_calc_bytes(alldata,crc32val,CHKVAL_STRUCT_CRC32VAL_SIZE,CALC_CRC32_SIZE,crc32pos,False,'[%s].chkval.[crc32]'%(incfile))
    alldata = format_calc_bytes(alldata,md5val,CHKVAL_STRUCT_MD5VAL_SIZE,CALC_MD5_SIZE,md5pos, True,'[%s].chkval.[md5]'%(incfile))
    alldata = format_calc_bytes(alldata,sha256val,CHKVAL_STRUCT_SHA256VAL_SIZE,CALC_SHA256_SIZE, sha256pos,True,'[%s].chkval.[sha256]'%(incfile))
    alldata = format_calc_bytes(alldata,sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,CALC_SHA3_SIZE,sha3pos,True,'[%s].chkval.[sha3]'%(incfile))

    # to get the position for the sha3 code of the functions
    namexor1pos = get_value_check_offset(valuechecksdict, objparser, CHKVAL_STRUCT_NAMEXOR1)
    startfuncpos = get_function_name_offset(objparser,odict,incfile,CHKVAL_START_FUNCTION_NAME)
    endfuncpos = get_function_name_offset(objparser,odict,incfile,CHKVAL_END_FUNCTION_NAME)
    realdata = alldata[startfuncpos:endfuncpos]


    sha3val = get_sha3_value(realdata)
    sha3bytes = format_bytes(sha3val,CHKVAL_STRUCT_SHA3VAL_SIZE,True)
    alldata = set_data_bytes(alldata,sha3bytes,namexor1pos)

    realdata = []
    realdata.extend(alldata[startoff:totalendoff])
    sizebytes = zero_bytes(CHKVAL_STRUCT_SIZE_SIZE)
    # clear the bytes ,and it will give clear
    realdata = set_data_bytes(realdata,sizebytes, (sizepos - startoff))
    crcval = get_crc_sum(realdata)
    # now we should make change
    crcval = 0x100000000 - crcval
    # not overflow
    crcval = crcval & 0xffffffff
    crcbytes = format_bytes('%x'%(crcval), 4 , False)
    # to search for the position
    setpos = (sizepos - startoff)
    while (setpos % 4) != 0:
        setpos += 1
    realdata = set_data_bytes(realdata,crcbytes, setpos)
    alldata = set_data_bytes(alldata, realdata,startoff)


    return odict,alldata

def chkval_fill_inc(args,objparser,exefile,alldata,odict,incfile,win32mode):
    incodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,incfile)
    basefuncname = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,incfile,CHKVAL_BASE_FUNCTION_NAME)
    assert(basefuncname is not None)
    assert(incodict is not None)
    basefuncodict = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RAW_DATA,incfile,basefuncname)
    assert(basefuncodict is not None)
    basefuncdata = get_odict_value(basefuncodict,CHKVAL_RDATA_DATAS)
    basefuncrelocs = get_odict_value(basefuncodict, CHKVAL_RDATA_RELOCS)
    realf = basefuncname
    if win32mode:
        realf = '_%s'%(basefuncname)
    basefuncoff = objparser.get_text_file_off(basefuncdata,basefuncrelocs,realf)
    incdatastartdata = get_odict_value(odict,CHKVAL_KEY, CHKVAL_OBJ_DATA, incfile,CHKVAL_FUNC_CHECKS_START)
    assert(incdatastartdata is not None)
    incdatastartrels = zero_bytes(len(incdatastartdata))
    incdataenddata = get_odict_value(odict,CHKVAL_KEY,CHKVAL_OBJ_DATA, incfile,CHKVAL_VALUE_CHECKS_TOTAL_END)
    assert(incdataenddata is not None)
    incdataendrels = zero_bytes(len(incdataenddata))
    incdatapos = objparser.get_text_file_off(incdatastartdata,incdatastartrels,CHKVAL_FUNC_CHECKS_START)
    incendpos = objparser.get_text_file_off(incdataenddata, incdataendrels, CHKVAL_VALUE_CHECKS_TOTAL_END)
    incdatas = alldata[incdatapos:incendpos]
    incobjparser = ObjParser()
    sb = ints_to_bytes(incdatas)
    poff = incobjparser.get_text_file_off(incdatas[:CHKVAL_STRUCT_OFFSET_SIZE], zero_bytes(CHKVAL_STRUCT_OFFSET_SIZE),CHKVAL_STRUCT_OFFSET,sb)
    assert(poff >= 0)
    assert(basefuncoff >= 0)
    for o in incodict.keys():
        odict,alldata = chkval_fill_inc_obj(args,objparser,exefile,alldata,odict,incfile,o,basefuncoff,incobjparser, incdatas,incdatapos,win32mode)
    odict, alldata = chkval_fill_inc_lastitem(args,objparser,exefile,alldata,odict,incfile,win32mode)
    odict,alldata = __inc_filled_self(args,objparser,exefile,alldata,odict,incfile,win32mode)
    return odict,alldata

def chkval_fill_data(args,objtype,odict,exefile,chkobjs=[],win32mode=False):
    objparser = call_object_parser(objtype,exefile)
    alldata = objparser.get_data()
    for f in chkobjs:
        odict,alldata = chkval_fill_inc(args,objparser,exefile,alldata,odict,f,win32mode)
    objparser.close()
    write_file_ints(alldata, exefile)
    return odict

def single_chkval_data_format(args,objfile,odict,jdict):
    chkval = ChkVal(args.input,None,None)
    if CHKVAL_KEY not in odict.keys():
        odict[CHKVAL_KEY] = dict()
    rets = ''

    # we put the obcode is for the handle OB_RANDOM_NAME macro expand
    rets += format_line('#include <obcode.h>',0)

    curs, odict[CHKVAL_KEY] = chkval.format_c_code_pre(args,odict[CHKVAL_KEY],objfile)
    rets += curs


    curs , odict[CHKVAL_KEY] = chkval.format_c_code(odict[CHKVAL_KEY],objfile,jdict)
    rets += curs

    curs , odict[CHKVAL_KEY] = chkval.format_c_code_post(odict[CHKVAL_KEY],objfile)
    rets += curs

    return rets,odict


def fmtchkval_handler(args,parser):
    set_logging_level(args)
    jdict,args = get_jdict(args)
    odict = get_odict(args,False)
    files = chkval_data_files(args,odict,args.obchkkey)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    idx = 0
    while idx < len(files):
        rets,odict = single_chkval_data_format(args,objs[idx],odict,jdict)
        write_file(rets,files[idx])
        chkval = ChkVal(files[idx],None,None)
        rets , dummydict = chkval.expand_chkval_code()
        write_file(rets,files[idx])
        idx += 1
    write_json(odict,args.dump)
    return

def chkvalheader_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    if CHKVAL_KEY not in odict.keys():
        odict[CHKVAL_KEY] = dict()
    chkval = ChkVal(None,None,None)
    rets = ''
    rets += chkval.format_chkval_header(odict[CHKVAL_KEY],objs)

    write_file(rets,args.output)
    write_json(odict,args.dump)
    return

def replchkval_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args, False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    exitobjs = chkval_exit_objs(args,odict,args.obchkkey)
    rets = ''
    chkval = ChkVal(args.input,None,None)
    rets += chkval.replace_functions(odict[CHKVAL_KEY],objs,exitobjs,args.failfunc)
    write_file(rets, args.output)
    return

def chkvaldumpfuncself_handler(args,parser):
    set_logging_level(args)
    logging.info('chkvaldumpfuncself')
    jdict, args = get_jdict(args)
    odict = get_odict(args, False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    for f in objs:
        curobjs = []
        files = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,f)
        if files is not None:
            for k in files.keys():
                curobjs.append(k)
            args.output = f
            odict = chkval_dump_object_functions(args,'ElfParser',odict,curobjs)
    write_json(odict, args.dump)
    return

def chkvaldumpfuncscoff_handler(args,parser):
    set_logging_level(args)
    logging.info('chkvaldumpfuncscoff')
    jdict, args = get_jdict(args)
    odict = get_odict(args, False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    for f in objs:
        curobjs = []
        files = get_odict_value(odict,CHKVAL_KEY,CHKVAL_RANDOM_VALUE,f)
        if files is not None:
            for k in files.keys():
                curobjs.append(k)
            args.output = f
            odict = chkval_dump_object_functions(args,'CoffParser',odict,curobjs,args.win32)
    write_json(odict, args.dump)
    return


def chkvalfillelf_handler(args,parser):
    set_logging_level(args)
    logging.info('chkvalfillelf')
    jdict, args = get_jdict(args)
    odict = get_odict(args, False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    odict = chkval_fill_data(args,'ElfParser',odict,args.output,objs)
    write_json(odict,args.dump)
    return

def chkvalfillpe_handler(args,parser):
    set_logging_level(args)
    logging.info('chkvalfillpe')
    jdict, args = get_jdict(args)
    odict = get_odict(args, False)
    objs = chkval_data_objs(args,odict,args.obchkkey)
    odict = chkval_fill_data(args,'PEParser',odict,args.output,objs,args.win32)
    write_json(odict,args.dump)
    return


def chkvalfillforge_handler(args,parser):
    set_logging_level(args)
    return


def chkvaldumpfuncsforge_handler(args,parser):
    set_logging_level(args)
    return

def __format_header_empty(namelen):
    guardval = '__%s__'%(get_random_name(namelen))
    rets =  ''
    rets += format_line('#ifndef %s'%(guardval),0)
    rets += format_line('#define %s'%(guardval),0)
    rets += format_line('',0)
    rets += format_line('#endif /*%s*/'%(guardval),0)
    return rets

def chkvalheaderforge_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    rets = __format_header_empty(random.randint(10,30))
    if args.output is None:
        write_file_direct(rets,sys.stdout)
    else:
        write_file(rets,args.output)
    return

def fmtchkvalforge_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    files = chkval_data_files(args,odict,args.obchkkey)
    idx = 0
    while idx < len(files):
        rets = ''
        write_file(rets,files[idx])
        idx += 1
    return

def replchkvalforge_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    rets = read_file(args.input)
    write_file(rets,args.output)
    return

def chkvalexitfmtforge_handler(args,parser):
    set_logging_level(args)    
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    objs = chkval_exit_objs(args,odict,args.obchkkey)
    files = chkval_exit_files(args,odict,args.obchkkey)
    idx = 0
    while idx < len(files):
        rets = ''
        write_file(rets,files[idx])
        idx += 1
    return


def chkvalexitfmt_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    files = chkval_exit_files(args,odict,args.obchkkey)
    objs = chkval_exit_objs(args,odict,args.obchkkey)
    chkval = ChkVal(args.input,None,None)
    odict = create_odict_is_none(odict,CHKVAL_KEY)
    idx = 0
    while idx < len(files):
        rets,odict[CHKVAL_KEY] = chkval.expand_chkval_code(objs[idx],odict[CHKVAL_KEY])
        write_file(rets,files[idx])
        idx += 1
    write_json(odict,args.dump)
    return

def exitheaderfmtforge_handler(args,parser):
    set_logging_level(args)
    jdict, args= get_jdict(args)
    rets = __format_header_empty(random.randint(10,30))
    write_file(rets,args.output)
    return

def format_exit_header(args,odict,obchkkeys=[]):
    rets = ''
    guardval = '__%s__'%(get_random_name(random.randint(10,30)))
    rets += format_line('#ifndef %s'%(guardval),0)
    rets += format_line('#define %s'%(guardval),0)
    rets += format_line('',0)
    rets += format_line('#ifdef __cplusplus',0)
    rets += format_line('extern "C" {', 0)
    rets += format_line('#endif /*__cplusplus*/',0)
    d = args.appendpath
    d = os.path.abspath(d)
    for k in obchkkeys:
        objs = chkval_exit_objs(args,odict,k)
        for f in objs:
            funcname = get_odict_value(odict,CHKVAL_KEY,RANDOM_VARIABLE,f,args.failfunc)
            if funcname is not None:
                rets += format_line('',0)
                rets += format_debug_line('from [%s] file for [%s]'%(f,args.failfunc),0,3)
                rets += format_line('void %s(int errcode, char* fmt);'%(funcname),0)

    rets += format_line('',0)
    rets += format_line('#ifdef __cplusplus',0)
    rets += format_line('};', 0)
    rets += format_line('#endif /*__cplusplus*/',0)

    rets += format_line('',0)
    rets += format_line('#endif /*%s*/'%(guardval),0)
    return rets

def exitheaderfmt_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    obchkkeys = []
    for k in jdict.keys():
        obchkkeys.append(k)
    if len(obchkkeys) == 0:
        varobjs = get_odict_value(odict,CHKVAL_KEY,CHKVAL_EXIT_HANDLER_FILES)
        if varobjs is not None:
            for k in varobjs.keys():
                obchkkeys.append(k)
    rets = format_exit_header(args,odict,obchkkeys)
    write_file(rets,args.output)
    return



def chkvalexitfiles_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    keys = []
    for k in jdict.keys():
        keys.append(k)
    files = []
    for k in keys:
        files.extend(chkval_exit_files(args,odict,k))
    output_list(files,None,args.with_quote)
    return

def chkvalexitobjs_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    keys = []
    for k in jdict.keys():
        keys.append(k)
    objs = []    
    for k in keys:
        objs.extend(chkval_exit_objs(args,odict,k))
    output_list(objs,None,args.with_quote)
    return

def chkvaldatafiles_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    keys = []
    for k in jdict.keys():
        keys.append(k)
    files = []
    for k in keys:
        files.extend(chkval_data_files(args,odict,k))
    output_list(files,None,args.with_quote)
    return

def chkvaldataobjs_handler(args,parser):
    set_logging_level(args)
    jdict, args = get_jdict(args)
    odict = get_odict(args,False)
    keys = []
    for k in jdict.keys():
        keys.append(k)
    objs = []
    for k in keys:
        objs.extend(chkval_data_objs(args,odict,k))
    output_list(objs,None,args.with_quote)
    return


##extractcode_end